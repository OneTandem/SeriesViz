<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
</head>
<body>
	<div id="viz"></div>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script>
		d3.csv("series_2017.csv", (error, data) => {
			console.log(data);
			data.forEach(d => {
				d.Deviation = +d.Deviation;
				d.Episode = +d.Episode;
				d.Season = +d.Season;
				d["User Rating"] = +d["User Rating"];
				d["User Votes"] = +d["User Votes"];
			});

			var deviation_range = d3.extent(data, d => { return d.Deviation; })
				color = d3.scaleLinear()
					.domain([deviation_range[0], 0, deviation_range[1]])
    				//.range(["#9E3D22", "white", "#2B5C8A"]);
    				.range(["red", "#eee", "green"])

    		console.log(deviation_range);

    		var nested_data_by_series = d3.nest()
				.key(function(d) { return d.Serie; })								
		
				//.key(function(d) { return d.Episode; })
				.rollup((leaves) => { return d3.mean(leaves, p => { return p["User Rating"]; }) })
				.entries(data);

			console.log(nested_data_by_series)

			var nested_data = d3.nest()
				.key(function(d) { return d.Serie; })								
				.key(function(d) { return d.Season; })
		
				//.key(function(d) { return d.Episode; })
				.rollup(function(leaves) { 
					return {
						avg_rating: d3.mean(leaves, p => { return p["User Rating"]; }),
						total_rating: d3.sum(leaves, p => { return p["User Rating"]; }),
						episodes: leaves
					}})
				.entries(data);

			nested_data.forEach((d, i) => {
				nested_data[i].avg_rating = nested_data_by_series[i].value;
			});

			var total_seasons = d3.sum(nested_data, d => { return d.values.length; }) + 1;

			console.log(nested_data)

			const width = 800, 
				height = 1100;				

			const margin = {top: 20, right: 10, bottom: 10, left: 10};

			var vizWidth = width - margin.left - margin.right,
				vizHeight = height - margin.top - margin.bottom,
				squareSize = (vizHeight) / total_seasons;

				console.log(squareSize)

			var currentSeriesY = 0;

			var viz = d3.select("#viz").append("svg")
				.attr("width", vizWidth)
				.attr("height", vizHeight)
				.append("g")
    				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    		viz.selectAll("text")
    			.data(d3.range(1, d3.max(data, d => { return d.Episode; })))
    			.enter()
    				.append("text")
    					.attr("x", (d, i) => { return squareSize * i + 200; })
    					.attr("y", -5)
    					.text(d => { return d; })

    		var series = viz.selectAll("g")
    			.data(nested_data.sort((a, b) => { 
    				console.log(a)
    				return d3.descending;
    			}))
    			.enter()
    			.append("g")
    				.attr("class", "serie")
    				.attr("transform", (d, i) => { 
    					console.log(d);    					
    					translate = "translate(0, " + currentSeriesY + ")";
    					currentSeriesY += squareSize * d.values.length;
    					return translate;
    				});

			currentSeriesY = 0;

    		series.selectAll("text")
				.data(nested_data)
    			.enter()
    			.append("text")
    				.attr("class", "seriesname")	
    				.attr("x", 0)
    				.attr("y", (d, i) => {
    					var midY = currentSeriesY + (d.values.length * squareSize / 2);
    					currentSeriesY += squareSize * d.values.length;    			
    					return midY;		    				
    				})
    				.text(d => { return d.key; })

    		var seasons = series.selectAll("g")
    			.data(d => { return d.values; })
    			.enter()
    			.append("g")
    				.attr("class", "season")    				
    				.attr("transform", (d, i) => { 
    					translate = "translate(200, " + squareSize * i + ")";
    					return translate;
					});	

    		seasons.selectAll("rect")
    			.data(d => { return d.value.episodes; })
    			.enter()
    			.append("rect")
    				.attr("width", squareSize)
    				.attr("height", squareSize)
    				.attr("x", (d, i) => {
    					return i * squareSize;
    				})
    				.attr("y", 0)
    				.attr("fill", d => { return color(d.Deviation); })
    				.style("stroke", "white");   

    		/*series.selectAll("text")
    			 .data(d => { return d.values; })
    			 .enter()
    			 .append("text")
	    			 .attr("x", -10)
    				.attr("y", squareSize)
    				.text(d => { return d.key; })*/
		});
	</script>

</body>
</html>